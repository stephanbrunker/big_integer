'=================================================================
'      BIGINT OPERATORS
'=================================================================
' unary plus +
'================================================================
Operator + (ByRef x As Bigint) As Bigint
	Return x
End Operator

' unary minus -
'================================================================
Operator - (ByRef a As Bigint) As Bigint
	' Negate the twos complement binary number in a Bigint
	Dim As Bigint s = a
	Dim As Long blocks = Len(s.s) \ 4
	Dim As ULongInt sum
	Dim As ULong carry
	Dim As ULong Ptr ps
	ps = Cast( ULong Ptr, StrPtr(s.s))' the Uinteger data in Bigint
	carry = 1       ' set carry
	Do  ' slow ahead until clear of the carry
		*ps = Not *ps
		sum = CULngInt(*ps) + carry
		*ps = sum
		carry = sum Shr 32
		ps += 1
		blocks -= 1
	Loop Until (carry = 0) Or (blocks = 0)
	If blocks > 0 Then
		Do  ' no carry, so full speed ahead
			*ps = Not *ps
			ps +=1
			blocks -= 1
		Loop Until blocks = 0
	End If
	' Negating the most negative integer is a problem because carry propagation
	' flips the sign which should have become positive. But negation of zero
	' does not change the sign either, so we need to differentiate between zero
	' and one by quickly examining the final carry bit from the two's complement.
	If carry = 0 Then ' carry was not generated by the most negative number
		If (128 And a.s[Len(a.s)-1]) = (128 And s.s[Len(s.s)-1]) Then s.s &= Bigint_s0
	End If  ' this prevents a negated zero being extended by an extra zero block
	Return s
End Operator

' addition
'================================================================
Operator + (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	If aa = bb Then
		Return Bigint.mul2(aa)
	ElseIf aa.s = Bigint_s0 Then
		Return bb
	ElseIf bb.s = Bigint_s0 Then
		Return aa
	End If
	Dim As Bigint a = aa, b = bb
	Dim As Long blocks, i, j, lena, lenb, sa, sb, delta
	'------------------------------------------------------------
	' test to see if the two most significant digits differ which
	lena = Len(a.s) - 1   ' might change the sign without carry
	If a.s[lena] And 128 Then sa = 255  ' sign as a byte
	i = a.s[lena] And 192 ' if MSBs differ then extend the sign
	If (i = 64) Or (i = 128) Then a.s = a.s + String(4, Chr(sa) )
	'------------------------------------------------------------
	lenb = Len(b.s) - 1
	If b.s[lenb] And 128 Then sb = 255
	i = b.s[lenb] And 192
	If (i = 64) Or (i = 128) Then b.s = b.s + String(4, Chr(sb) )
	'------------------------------------------------------------
	' align the two Bigints to be added
	delta = Len(a.s) - Len(b.s) ' new values
	If delta <> 0 Then  ' sign extend the shorter
		If delta > 0 Then
			' a = a
			If b.s[Len(b.s)-1] And 128 Then i = 255 Else i = 0
			b.s = b.s + String(delta, Chr(i) )  ' extend b
		Else
			If aa.s[Len(aa.s)-1] And 128 Then i = 255 Else i = 0
			a.s = a.s + String(-delta, Chr(i) )  ' extend a
			' b = b
		End If
	End If  ' a and b are now the same length
	'------------------------------------------------------------
	' accumulate b into a
	blocks = Len(a.s) \ 4
	Dim As ULongInt sum = 0 ' clear carry
	Dim As ULong carry
	Dim As ULong Ptr pa, pb
	pa = Cast(ULong Ptr, StrPtr(a.s) )
	pb = Cast(ULong Ptr, StrPtr(b.s) )
	For i = 0 To blocks-1
		sum = CULngInt(pa[i]) + pb[i] + carry
		pa[i] = sum
		carry = sum Shr 32
	Next i
	Bigint.prune(a)
	Return a
End Operator

' subtraction
'================================================================
Operator - (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	Dim As Bigint cc = aa + (-bb)
	Return cc
End Operator

' multiply
'================================================================
Operator * (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	If aa.s = Bigint_s0 Or bb.s = Bigint_s0 Then
		Return 0
	ElseIf aa.s = Bigint_s1 Then
		Return bb
	ElseIf bb.s = Bigint_s1 Then
		Return aa
	ElseIf aa = bb Then
		Return bigint.square(aa)  ' squaring is faster
	ElseIf aa.s = Bigint_s2 Then
		Return Bigint.mul2(bb)
	ElseIf bb.s = Bigint_s2 Then
		Return Bigint.mul2(aa)
	Else
		' sort out the signs and rectify the inputs
		Dim As Bigint a = aa, b = bb, c
		Dim As Long sign_a, sign_b, sign_c
		sign_a = a.s[Len(a.s)-1] And 128
		sign_b = b.s[Len(b.s)-1] And 128
		sign_c = sign_a Xor sign_b
		If sign_a Then a = -a
		If sign_b Then b = -b
		'------------------------------------------------------------
		' find the dimensions of the problem
		Dim As Long i, j, asize, bsize
		asize = Len(a.s) ' number of bytes in a
		bsize = Len(b.s) ' number of bytes in b
		c.s = String(asize + bsize, Chr(0)) ' initialise accumulator
		asize = asize \ 4 - 1 ' number of blocks in a
		bsize = bsize \ 4 - 1
		'------------------------------------------------------------
		' pointers into all the Bigints
		Dim As ULong Ptr ia, ib, ic
		ia = Cast(ULong Ptr, StrPtr(a.s) )
		ib = Cast(ULong Ptr, StrPtr(b.s) )
		ic = Cast(ULong Ptr, StrPtr(c.s) )
		Dim As ULongInt product
		Dim As ULong carry
		'------------------------------------------------------------
		For i = 0 To asize
			carry = 0  ' clear carry
			For j = 0 To bsize
				product = CULngInt(ia[i]) * ib[j] + ic[i+j] + carry
				ic[i+j] = product
				carry = product Shr 32
			Next j
			ic[i+j] = carry
		Next i
		'------------------------------------------------------------
		If sign_c = 128 Then c = - c
		Bigint.prune(c)
		Return c
	End If
End Operator

Operator \ (ByRef x As Bigint, ByRef y As Bigint) As Bigint
	Dim As Bigint a,b
	bigint.div(x,y,a,b)
	Return a
End Operator

Operator / (ByRef x As Bigint, ByRef y As Bigint) As Bigint
	Print "no floating point division in Big_Integer"
	Sleep: End
	Return 0
End Operator

Operator Mod (ByRef x As Bigint, ByRef y As Bigint) As Bigint
	Dim As Bigint c,d
	bigint.div(x,y,c,d)
	Return d
End Operator

' exponentiation
'================================================================
Operator ^ (ByRef x As Bigint, ByRef n As LongInt) As Bigint
	If n = 2 Then
		Return bigint.square(x)
	Else
		If n < 0 Then
			Print "Cannot raise a big integer to a negative power."
			Sleep : End
		End If
		Dim As Long i = 64
		Do  ' find first set bit
			i = i - 1
		Loop Until Bit(n, i) Or (i = 0)
		i = i + 1
		Dim As Bigint pwr
		pwr = 1
		Do
			i = i - 1
			pwr = bigint.square(pwr)  ' this was a multiply but square is faster
			If Bit(n, i) Then pwr = pwr * x
		Loop Until i = 0
		Return pwr  ' pwr was pruned by square and by multiply
	End If
End Operator

' NOT. Invert all the bits in a Bigint
'================================================================
Operator Not (ByRef aa As Bigint) As Bigint
	Dim As Bigint a = aa
	For i As Long = 0 To Len(a.s)-1
		a.s[i] = 255 - a.s[i]
	Next i
	Return a
End Operator

' shift Bigint n bits left
'================================================================
Operator Shl (ByRef a As Bigint, ByVal n As LongInt) As Bigint
	If n = 0 Then Return a
	If n < 0 Then Return 0
	If a.s = Bigint_s0 Then Return 0
	Dim As LongInt nblocks = n \ 32
	Dim As Byte nbits = n Mod 32
	Dim As Bigint s
	Dim As ULong m = BitSet(CLng(0), nbits)
	s.s = String(nblocks * 4, Chr(0)) + a.s  ' put zeros on the rhs
	s = m * s
	Return s
End Operator

' shift Bigint n bits right, by shifting left nbits and right nblocks
'================================================================
Operator Shr (ByRef a As Bigint, ByVal n As LongInt) As Bigint
	If n = 0 Then Return a
	If n < 0 Then Return 0
	If n > (8 * Len(a.s)) Then Return 0
	Dim As LongInt nblocks = n \ 32
	Dim As Byte nbits = n Mod 32
	Dim As Bigint s = a
	Dim As ULongint m = BitSet(CLngint(0), 32 - nbits )
	s = m * s  ' move bits left
	s.s = Right(s.s, Len(s.s) - (nblocks+1)*4 )
	If Len(s.s) = 0 Then Return 0
	Return s
End Operator

' bitwise AND
'================================================================
Operator And (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	Dim As Bigint a = aa, b = bb, c
	Dim As Long lena, lenb, i
	lena = Len(a.s)
	lenb = Len(b.s)
	If lena > lenb Then
		b.s = b.s + String(lena - lenb, Bit(b.s[lenb - 1], 7))
	Else
		a.s = a.s + String(lenb - lena, Bit(a.s[lena - 1], 7))
	End If
	c = b
	For i = 0 To Len(c.s) - 1
		c.s[i] = c.s[i] And a.s[i]
	Next i
	Return c
End Operator

' bitwise Or
'================================================================
Operator Or (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	Dim As Bigint a = aa, b = bb, c
	Dim As Long lena, lenb, i
	lena = Len(a.s)
	lenb = Len(b.s)
	If lena > lenb Then
		b.s = b.s + String(lena - lenb, Bit(b.s[lenb - 1], 7))
	Else
		a.s = a.s + String(lenb - lena, Bit(a.s[lena - 1], 7))
	End If
	c = b
	For i = 0 To Len(c.s) - 1
		c.s[i] = c.s[i] Or a.s[i]
	Next i
	Return c
End Operator

' bitwise Xor
'================================================================
Operator Xor (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	Dim As Bigint a = aa, b = bb, c
	Dim As Long lena, lenb, i
	lena = Len(a.s)
	lenb = Len(b.s)
	If lena > lenb Then
		b.s = b.s + String(lena - lenb, Bit(b.s[lenb - 1], 7))
	Else
		a.s = a.s + String(lenb - lena, Bit(a.s[lena - 1], 7))
	End If
	c = b
	For i = 0 To Len(c.s) - 1
		c.s[i] = c.s[i] Xor a.s[i]
	Next i
	Return c
End Operator

' bitwise Imp, implication
'================================================================
Operator Imp (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	Dim As Bigint a = aa, b = bb, c
	Dim As Long lena, lenb, i
	lena = Len(a.s)
	lenb = Len(b.s)
	If lena > lenb Then
		b.s = b.s + String(lena - lenb, Bit(b.s[lenb - 1], 7))
	Else
		a.s = a.s + String(lenb - lena, Bit(a.s[lena - 1], 7))
	End If
	c = b
	For i = 0 To Len(c.s) - 1
		c.s[i] = (c.s[i] Imp a.s[i])
	Next i
	Return c
End Operator

' bitwise Eqv, equivalence is the complement of Xor
'================================================================
Operator Eqv (ByRef aa As Bigint, ByRef bb As Bigint) As Bigint
	Dim As Bigint a = aa, b = bb, c
	Dim As Long lena, lenb, i
	lena = Len(a.s)
	lenb = Len(b.s)
	If lena > lenb Then
		b.s = b.s + String(lena - lenb, Bit(b.s[lenb - 1], 7))
	Else
		a.s = a.s + String(lenb - lena, Bit(a.s[lena - 1], 7))
	End If
	c = b
	For i = 0 To Len(c.s) - 1
		c.s[i] = (c.s[i] Eqv a.s[i])
	Next i
	Return c
End Operator

Operator Abs (ByRef a As Bigint) As Bigint
	Dim As Bigint b = a
	If 128 And b.s[Len(b.s)-1] Then b = - b
	Return b
End Operator

Operator Sgn (ByRef a As Bigint) As Integer
	Dim As Long i = 128 And a.s[Len(a.s)-1]
	If i Then Return -1 ' is negative
	If a.s = Bigint_s0 Then Return 0 ' is zero
	Return 1 ' is positive
End Operator
